// Generated by CoffeeScript 1.4.0
(function() {
  var Config, Gmetric, Jolokia, JolokiaSrv, Logger, async, fs, mkdirp, os, path,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  os = require('os');

  fs = require('fs');

  path = require('path');

  Jolokia = require('jolokia-client');

  async = require('async');

  mkdirp = require('mkdirp');

  Gmetric = require('gmetric');

  Config = require('./config');

  Logger = require('./logger');

  /**
   * Jolokia server client wrapper.
  */


  JolokiaSrv = (function() {

    function JolokiaSrv(interval) {
      this.interval = interval;
      this.submit_metrics = __bind(this.submit_metrics, this);
      this.stop_gmond = __bind(this.stop_gmond, this);
      this.start_gmond = __bind(this.start_gmond, this);
      this.info_all_clients = __bind(this.info_all_clients, this);
      this.query_jolokia = __bind(this.query_jolokia, this);
      this.lookup_attribute_or_composites = __bind(this.lookup_attribute_or_composites, this);
      this.generate_client_query = __bind(this.generate_client_query, this);
      this.generate_query_info = __bind(this.generate_query_info, this);
      this.generate_template_info = __bind(this.generate_template_info, this);
      this.merge_parent_templates = __bind(this.merge_parent_templates, this);
      this.info_client = __bind(this.info_client, this);
      this.remove_client = __bind(this.remove_client, this);
      this.list_clients = __bind(this.list_clients, this);
      this.convert_mappings_to_hash = __bind(this.convert_mappings_to_hash, this);
      this.add_client = __bind(this.add_client, this);
      this.list_templates = __bind(this.list_templates, this);
      this.unload_template = __bind(this.unload_template, this);
      this.load_template = __bind(this.load_template, this);
      this.load_all_templates = __bind(this.load_all_templates, this);
      this.watch_templates = __bind(this.watch_templates, this);
      this.setup_template_dir = __bind(this.setup_template_dir, this);
      this.interval || (this.interval = 20);
      this.jclients = new Object();
      this.templates = new Object();
      this.gmond_interval_id = null;
      this.gmetric = new Gmetric();
      this.config = Config.get();
      this.logger = Logger.get();
      this.setup_template_dir();
    }

    /**
     * Sets up the template directory and loads the current templates
    */


    JolokiaSrv.prototype.setup_template_dir = function() {
      var _this = this;
      return mkdirp(this.config.get('template_dir'), function(err) {
        if (err) {
          _this.logger.error("Error creating template directory: " + err);
          return process.exit(1);
        } else {
          return _this.watch_templates();
        }
      });
    };

    /**
     * Watch template directory and update @templates on changes.
     * @note watching with inotify is current only supported on linux,
     * other operating systems will drop to an initial-load only.
    */


    JolokiaSrv.prototype.watch_templates = function() {
      var _this = this;
      return this.load_all_templates(function() {
        if (os.platform() === 'linux') {
          return fs.watch(_this.config.get('template_dir'), function(event, filename) {
            return fs.exists(path.resolve(_this.config.get('template_dir'), filename), function(exists) {
              if (exists) {
                return _this.load_template(filename);
              } else {
                return _this.unload_template(filename);
              }
            });
          });
        }
      });
    };

    /**
     * Loads all of the current templates in the template directory.
     * @param {Function} (fn) The callback function
    */


    JolokiaSrv.prototype.load_all_templates = function(fn) {
      var _this = this;
      this.stop_gmond;
      return fs.readdir(path.resolve(this.config.get('template_dir')), function(err, files) {
        var json_files;
        json_files = files.filter(function(x) {
          return x.match(/\.json/);
        });
        return async.forEach(json_files, _this.load_template, function(err) {
          _this.start_gmond;
          if (fn) {
            return fn(err);
          }
        });
      });
    };

    /**
     * Removes the given template from the available templates.
     * @param {String}   (template) The template to remove
    */


    JolokiaSrv.prototype.load_template = function(template, fn) {
      var _this = this;
      return fs.readFile(path.resolve(this.config.get('template_dir'), template), 'utf8', function(err, data) {
        var json_data;
        if (err) {
          _this.logger.error("Error reading file: " + template);
        } else {
          try {
            json_data = JSON.parse(data);
            _this.templates[json_data.name] = {
              mappings: json_data.mappings
            };
          } catch (error) {
            _this.logger.error("Error parsing `" + template + "`: " + error);
          }
        }
        return fn(err);
      });
    };

    /**
     * Removes the given template from the available templates.
     * @param {String} (template) The template to remove
    */


    JolokiaSrv.prototype.unload_template = function(template) {
      return delete this.templates[template];
    };

    /**
     * The list of current templates.
     * @return {Array} The current list of templates
    */


    JolokiaSrv.prototype.list_templates = function() {
      return Object.keys(this.templates);
    };

    /**
     * Add a new jolokia lookup client into the hash.
     * @param  {String}  (name) The name of the client to add
     * @param  {String}  (url) The jolokia url for the client
     * @param  {Object}  (attributes) The attributes to lookup for the client
     * @return {Object}  The jolokia client that was added
    */


    JolokiaSrv.prototype.add_client = function(name, url, template) {
      return this.jclients[name] = {
        client: new Jolokia(url),
        name: name,
        url: url,
        template: template,
        cache: new Object()
      };
    };

    /**
     * Cleanup mappings for a client before they are cached for fast lookups.
     * @param {Object} (mappings) The metrics mappings for a given client
     * @param {Function} (fn) The callback function
    */


    JolokiaSrv.prototype.convert_mappings_to_hash = function(mappings, fn) {
      var _this = this;
      return async.reduce(mappings, new Object(), function(mbean_memo, mbean_attr, mbean_cb) {
        var _name;
        mbean_memo[_name = mbean_attr.mbean] || (mbean_memo[_name] = new Object());
        return async.reduce(mbean_attr.attributes, mbean_memo[mbean_attr.mbean], function(a_memo, a_attr, a_cb) {
          var _name1;
          a_memo[_name1 = a_attr.name] || (a_memo[_name1] = new Object());
          if (a_attr.hasOwnProperty('graph') && Object.keys(a_attr.graph).length > 0) {
            a_memo[a_attr.name].graph = a_attr.graph;
          }
          if (a_attr.hasOwnProperty('value')) {
            a_memo[a_attr.name].value = a_attr.value;
          }
          if (a_attr.hasOwnProperty('composites') && a_attr.composites.length > 0) {
            return async.forEach(a_attr.composites, function(cmp_attr, cmp_cb) {
              var _base, _name2;
              (_base = a_memo[a_attr.name])[_name2 = cmp_attr.name] || (_base[_name2] = new Object());
              if (cmp_attr.hasOwnProperty('graph') && Object.keys(cmp_attr.graph).length > 0) {
                a_memo[a_attr.name][cmp_attr.name].graph = cmp_attr.graph;
              }
              if (cmp_attr.hasOwnProperty('value')) {
                a_memo[a_attr.name][cmp_attr.name].value = cmp_attr.value;
              }
              return cmp_cb(null);
            }, function(cmp_err) {
              return a_cb(null, a_memo);
            });
          } else {
            return a_cb(null, a_memo);
          }
        }, function(a_err, a_results) {
          return mbean_cb(a_err, mbean_memo);
        });
      }, function(err, results) {
        return fn(err, results);
      });
    };

    /**
     * List the current jolokia clients.
     * @return {Array} The list of current clients
    */


    JolokiaSrv.prototype.list_clients = function() {
      return Object.keys(this.jclients);
    };

    /**
     * Removes a jolokia client from the hash.
     * @param  {String} (name) The name of the client to remove
    */


    JolokiaSrv.prototype.remove_client = function(name) {
      return delete this.jclients[name];
    };

    /**
     * Returns detailed information for the given client.
     * @param  {String} (name) The name of the client to lookup
     * @return {Object} The hash representing the client info
    */


    JolokiaSrv.prototype.info_client = function(name) {
      var client;
      client = this.jclients[name];
      if (client) {
        if (client.template) {
          return this.generate_template_info(client.template);
        } else {
          return {};
        }
      } else {
        return null;
      }
    };

    /**
     * TODO: Add support for merging parent templates
    */


    JolokiaSrv.prototype.merge_parent_templates = function(template) {
      delete this.templates[template].inherits;
      return this.templates[template];
    };

    /**
     * Generates the information for a given template including parents.
     * @param {String} (template) The template to generate information for
     * @param {Object} The merged information for a given template
    */


    JolokiaSrv.prototype.generate_template_info = function(template) {
      if (this.templates[template] === void 0) {
        return this.templates[template];
      }
      if (this.templates[template].inherits === null || this.templates[template].inherits === void 0) {
        this.templates[template].inherits = [];
      }
      if (this.templates[template].inherits.length > 0) {
        return this.merge_parent_templates(template);
      } else {
        delete this.templates[template].inherits;
        return this.templates[template];
      }
    };

    /**
     * Generates a query information for the JMX update.
     * @param  {Object} (mappings) The detailed information for a client
     * @return {Array}  The list of info objects
    */


    JolokiaSrv.prototype.generate_query_info = function(client) {
      var attr, c, g, m, query_info, _i, _j, _len, _len1, _ref, _ref1;
      query_info = [];
      if (client.mappings !== null) {
        _ref = client.mappings;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          m = _ref[_i];
          _ref1 = m.attributes;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            attr = _ref1[_j];
            if (attr.hasOwnProperty('graph')) {
              g = attr.graph;
            } else {
              g = {};
            }
            if (attr.hasOwnProperty('composites')) {
              c = attr.composites;
            } else {
              c = [];
            }
            query_info.push({
              mbean: m.mbean,
              attribute: attr.name,
              graph: g,
              composites: c
            });
          }
        }
        return query_info;
      }
    };

    /**
     * Generates a query array for the jolokia client.
     * @param  {Object} (query_info) The query info for a client
     * @return {Array}  The list of items to query
    */


    JolokiaSrv.prototype.generate_client_query = function(query_info) {
      var q, query, _i, _len;
      query = [];
      for (_i = 0, _len = query_info.length; _i < _len; _i++) {
        q = query_info[_i];
        query.push({
          mbean: q.mbean,
          attribute: q.attribute
        });
      }
      return query;
    };

    /**
     * Takes the query_info and response objects and gets the proper result set.
     * @param {String} (name) The name of the client to query
     * @param {Object} (mappings) The metrics mappings for a client
     * @param {Object} (response) The query response from jolokia
     * @param {Function} (fn) The callback function
    */


    JolokiaSrv.prototype.lookup_attribute_or_composites = function(name, mappings, response, fn) {
      var _this = this;
      return this.convert_mappings_to_hash(mappings, function(h_err, hattribs) {
        var handle_response_obj;
        handle_response_obj = function(item, cb) {
          var attribute, k, keys, mbean, recursive_get_val, retrieve_composite_value, value, _i, _len;
          mbean = item.request.mbean;
          attribute = item.request.attribute;
          value = item.value;
          retrieve_composite_value = function(input) {
            if (typeof input === 'string') {
              input = input.split('|');
            }
            return recursive_get_val(value, input);
          };
          recursive_get_val = function(walk, list) {
            var next;
            if (list.length > 1) {
              next = list.shift();
              return recursive_get_val(walk[next], list);
            } else {
              return walk[list];
            }
          };
          if (hattribs[mbean][attribute].hasOwnProperty('graph') && Object.keys(hattribs[mbean][attribute].graph).length > 0) {
            hattribs[mbean][attribute].value = value;
          }
          keys = (function() {
            var _i, _len, _ref, _results;
            _ref = Object.keys(hattribs[mbean][attribute]);
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              k = _ref[_i];
              if (k !== 'graph' && k !== 'value') {
                _results.push(k);
              }
            }
            return _results;
          })();
          for (_i = 0, _len = keys.length; _i < _len; _i++) {
            k = keys[_i];
            hattribs[mbean][attribute][k].value = retrieve_composite_value(k);
          }
          return cb(null);
        };
        return async.forEach(response, handle_response_obj, function(err) {
          _this.jclients[name].cache = hattribs;
          return fn(null, hattribs);
        });
      });
    };

    /**
     * Queries jolokia mbeans for a given client and updates their values.
     * @param {String} (name) The name of the client to query
     * @param {Function} (fn) The callback function
    */


    JolokiaSrv.prototype.query_jolokia = function(name, fn) {
      var cinfo, client, query, query_info, util,
        _this = this;
      util = require('util');
      cinfo = this.info_client(name);
      query_info = this.generate_query_info(cinfo);
      query = this.generate_client_query(query_info);
      if (query === []) {
        return null;
      }
      client = this.jclients[name].client;
      return client.read(query, function(response) {
        return _this.lookup_attribute_or_composites(name, cinfo.mappings, response, fn);
      });
    };

    /**
     * Returns detailed information for all clients.
     * @return {Object} The hash representing the all client info
    */


    JolokiaSrv.prototype.info_all_clients = function() {
      var clients, key, _i, _len, _ref;
      clients = new Object();
      _ref = Object.keys(this.jclients);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        clients[key] = this.info_client(key);
      }
      return clients;
    };

    /**
     * Starts up the gmond metric spooler.
    */


    JolokiaSrv.prototype.start_gmond = function() {
      var _this = this;
      if (!this.interval) {
        return;
      }
      if (this.gmond_interval_id) {
        stop_gmond();
      }
      return this.gmond_interval_id = setInterval(function() {
        return _this.submit_metrics();
      }, this.interval * 1000);
    };

    /**
     * Stops the gmond metric spooler.
    */


    JolokiaSrv.prototype.stop_gmond = function() {
      if (this.gmond_interval_id) {
        clearInterval(this.gmond_interval_id);
        return this.gmond_interval_id = null;
      }
    };

    /**
     * Submits gmetric data to the gmond target.
     * ex:  { host:  'exhost.domain.com',
     *        name:  'mygraphname',
     *        units: 'percentage', 
     *        type:  'int32',
     *        slope: 'both',
     *        tmax:   60,
     *        dmax:   120,
     *        group:  'mygraph_group' }
    */


    JolokiaSrv.prototype.submit_metrics = function() {
      var clientlist, compile_and_submit_metric, walk_graphs,
        _this = this;
      clientlist = Object.keys(this.jclients);
      if (!(clientlist.length > 0)) {
        return;
      }
      walk_graphs = function(client, cache) {
        var ainfo, attrib, c, comp, mbean, _i, _len, _ref, _results;
        if (Object.keys(_this.jclients[client]) === 0) {
          cb(null);
        }
        _ref = Object.keys(cache);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          mbean = _ref[_i];
          _results.push((function() {
            var _j, _len1, _ref1, _results1;
            _ref1 = Object.keys(cache[mbean]);
            _results1 = [];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              attrib = _ref1[_j];
              ainfo = cache[mbean][attrib];
              if (ainfo.hasOwnProperty('graph') && ainfo.hasOwnProperty('value')) {
                compile_and_submit_metric(client, ainfo.graph, ainfo.value);
              }
              _results1.push((function() {
                var _k, _len2, _ref2, _results2;
                _ref2 = Object.keys(cache[mbean][attrib]);
                _results2 = [];
                for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                  comp = _ref2[_k];
                  c = cache[mbean][attrib][comp];
                  if (c.hasOwnProperty('graph') && c.hasOwnProperty('value')) {
                    _results2.push(compile_and_submit_metric(client, c.graph, c.value));
                  } else {
                    _results2.push(void 0);
                  }
                }
                return _results2;
              })());
            }
            return _results1;
          })());
        }
        return _results;
      };
      compile_and_submit_metric = function(client, graph, value) {
        var cluster_prefix, metric;
        metric = graph;
        metric.value = value;
        cluster_prefix = _this.config.get('cluster_prefix');
        if (cluster_prefix !== null && cluster_prefix !== void 0) {
          client = "" + cluster_prefix + "_" + client;
        }
        metric.hostname = client;
        metric.spoof = true;
        metric.spoof_host = client;
        if (metric.type === void 0) {
          metric.type = 'int32';
        }
        if (metric.slope === void 0) {
          metric.slope = 'both';
        }
        return _this.gmetric.send(_this.config.get('gmetric'), _this.config.get('gPort'), metric);
      };
      return async.forEach(clientlist, function(client, cb) {
        return walk_graphs(client, _this.jclients[client].cache);
      }, function(err) {
        return _this.logger.error("Error submitting metrics: " + err);
      });
    };

    return JolokiaSrv;

  })();

  module.exports = JolokiaSrv;

}).call(this);
