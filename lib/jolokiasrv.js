// Generated by CoffeeScript 1.4.0
(function() {
  var Config, Gmetric, Jolokia, JolokiaSrv, Logger, async, fs, mkdirp, os, path, util,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  os = require('os');

  fs = require('fs');

  path = require('path');

  util = require('util');

  Jolokia = require('jolokia-client');

  async = require('async');

  mkdirp = require('mkdirp');

  Gmetric = require('gmetric');

  Config = require('./config');

  Logger = require('./logger');

  /**
   * Jolokia server client wrapper.
  */


  JolokiaSrv = (function() {

    function JolokiaSrv(interval) {
      this.interval = interval != null ? interval : 20;
      this.submit_metrics = __bind(this.submit_metrics, this);
      this.stop_gmond = __bind(this.stop_gmond, this);
      this.start_gmond = __bind(this.start_gmond, this);
      this.info_all_clients = __bind(this.info_all_clients, this);
      this.query_all_jolokia_nodes = __bind(this.query_all_jolokia_nodes, this);
      this.query_jolokia = __bind(this.query_jolokia, this);
      this.lookup_attribute_or_composites = __bind(this.lookup_attribute_or_composites, this);
      this.generate_client_query = __bind(this.generate_client_query, this);
      this.generate_query_info = __bind(this.generate_query_info, this);
      this.generate_template_info = __bind(this.generate_template_info, this);
      this.merge_attributes_or_composites = __bind(this.merge_attributes_or_composites, this);
      this.merge_mappings = __bind(this.merge_mappings, this);
      this.merge_parent_templates = __bind(this.merge_parent_templates, this);
      this.sort_mbean = __bind(this.sort_mbean, this);
      this.info_client = __bind(this.info_client, this);
      this.remove_client = __bind(this.remove_client, this);
      this.list_clients = __bind(this.list_clients, this);
      this.convert_mappings_to_hash = __bind(this.convert_mappings_to_hash, this);
      this.add_client = __bind(this.add_client, this);
      this.list_templates = __bind(this.list_templates, this);
      this.unload_template = __bind(this.unload_template, this);
      this.load_template = __bind(this.load_template, this);
      this.load_all_templates = __bind(this.load_all_templates, this);
      this.watch_templates = __bind(this.watch_templates, this);
      this.setup_template_dir = __bind(this.setup_template_dir, this);
      this.jclients = new Object();
      this.templates = new Object();
      this.gmond_interval_id = null;
      this.gmetric = new Gmetric();
      this.config = Config.get();
      this.logger = Logger.get();
      this.setup_template_dir();
    }

    /**
     * Sets up the template directory and loads the current templates
    */


    JolokiaSrv.prototype.setup_template_dir = function() {
      var _this = this;
      return mkdirp(this.config.get('template_dir'), function(err) {
        if (err) {
          _this.logger.error("Error creating template directory: " + err);
          return process.exit(1);
        } else {
          return _this.watch_templates();
        }
      });
    };

    /**
     * Watch template directory and update @templates on changes.
     * @note watching with inotify is current only supported on linux,
     * other operating systems will drop to an initial-load only.
    */


    JolokiaSrv.prototype.watch_templates = function() {
      var _this = this;
      return this.load_all_templates(function(err) {
        if (os.platform() === 'linux') {
          return fs.watch(_this.config.get('template_dir'), function(event, filename) {
            return fs.exists(path.resolve(_this.config.get('template_dir'), filename), function(exists) {
              if (exists) {
                return _this.load_template(filename);
              } else {
                return _this.unload_template(filename);
              }
            });
          });
        }
      });
    };

    /**
     * Loads all of the current templates in the template directory.
     * @param {Function} (fn) The callback function
    */


    JolokiaSrv.prototype.load_all_templates = function(fn) {
      var _this = this;
      this.stop_gmond();
      return fs.readdir(path.resolve(this.config.get('template_dir')), function(err, files) {
        var json_files;
        if (files === void 0) {
          json_files = [];
        } else {
          json_files = files.filter(function(x) {
            return x.match(/\.json/);
          });
        }
        return async.each(json_files, _this.load_template, function(err) {
          _this.start_gmond();
          if (fn !== void 0) {
            return fn(err);
          }
        });
      });
    };

    /**
     * Removes the given template from the available templates.
     * @param {String}   (template) The template to remove
    */


    JolokiaSrv.prototype.load_template = function(template, fn) {
      var _this = this;
      return fs.readFile(path.resolve(this.config.get('template_dir'), template), 'utf8', function(err, data) {
        var json_data;
        if (err) {
          _this.logger.error("Error reading file: " + template + ": " + err);
        } else {
          try {
            json_data = JSON.parse(data);
            _this.templates[json_data.name] = {
              inherits: json_data.inherits,
              mappings: json_data.mappings
            };
          } catch (error) {
            _this.logger.error("Error parsing `" + template + "`: " + error);
          }
        }
        if (fn !== void 0) {
          return fn(err);
        }
      });
    };

    /**
     * Removes the given template from the available templates.
     * @param {String} (template) The template to remove
    */


    JolokiaSrv.prototype.unload_template = function(template) {
      return delete this.templates[template];
    };

    /**
     * The list of current templates.
     * @return {Array} The current list of templates
    */


    JolokiaSrv.prototype.list_templates = function() {
      return Object.keys(this.templates);
    };

    /**
     * Add a new jolokia lookup client into the hash.
     * @param  {String} (name) The name of the client to add
     * @param  {String} (url) The jolokia url for the client
     * @param  {Object} (template) The attributes template
     * @param  {Object} (cluster) The cluster for the client
     * @return {Object} The jolokia client that was added
    */


    JolokiaSrv.prototype.add_client = function(name, url, template, cluster) {
      return this.jclients[name] = {
        client: new Jolokia(url),
        name: name,
        cluster: cluster,
        url: url,
        template: template,
        cache: new Object()
      };
    };

    /**
     * Cleanup mappings for a client before they are cached for fast lookups.
     * @param {Object} (mappings) The metrics mappings for a given client
     * @param {Function} (fn) The callback function
    */


    JolokiaSrv.prototype.convert_mappings_to_hash = function(mappings, fn) {
      var _this = this;
      return async.reduce(mappings, new Object(), function(mbean_memo, mbean_attr, mbean_cb) {
        var _name;
        mbean_memo[_name = mbean_attr.mbean] || (mbean_memo[_name] = new Object());
        return async.reduce(mbean_attr.attributes, mbean_memo[mbean_attr.mbean], function(a_memo, a_attr, a_cb) {
          var _name1;
          a_memo[_name1 = a_attr.name] || (a_memo[_name1] = new Object());
          if (a_attr.hasOwnProperty('graph') && Object.keys(a_attr.graph).length > 0) {
            a_memo[a_attr.name].graph = a_attr.graph;
          }
          if (a_attr.hasOwnProperty('value')) {
            a_memo[a_attr.name].value = a_attr.value;
          }
          if (a_attr.hasOwnProperty('composites') && a_attr.composites.length > 0) {
            return async.each(a_attr.composites, function(cmp_attr, cmp_cb) {
              var _base, _name2;
              (_base = a_memo[a_attr.name])[_name2 = cmp_attr.name] || (_base[_name2] = new Object());
              if (cmp_attr.hasOwnProperty('graph') && Object.keys(cmp_attr.graph).length > 0) {
                a_memo[a_attr.name][cmp_attr.name].graph = cmp_attr.graph;
              }
              if (cmp_attr.hasOwnProperty('value')) {
                a_memo[a_attr.name][cmp_attr.name].value = cmp_attr.value;
              }
              return cmp_cb(null);
            }, function(cmp_err) {
              return a_cb(null, a_memo);
            });
          } else {
            return a_cb(null, a_memo);
          }
        }, function(a_err, a_results) {
          return mbean_cb(a_err, mbean_memo);
        });
      }, function(err, results) {
        return fn(err, results);
      });
    };

    /**
     * List the current jolokia clients.
     * @return {Array} The list of current clients
    */


    JolokiaSrv.prototype.list_clients = function() {
      return Object.keys(this.jclients);
    };

    /**
     * Removes a jolokia client from the hash.
     * @param  {String} (name) The name of the client to remove
    */


    JolokiaSrv.prototype.remove_client = function(name) {
      return delete this.jclients[name];
    };

    /**
     * Returns detailed information for the given client.
     * @param  {String} (name) The name of the client to lookup
     * @return {Object} The hash representing the client info
    */


    JolokiaSrv.prototype.info_client = function(name) {
      var client;
      client = this.jclients[name];
      if (client) {
        if (client.template) {
          return this.generate_template_info(client.template);
        } else {
          return {};
        }
      } else {
        return null;
      }
    };

    /**
     * Sort mbean entries to handle jolokia silliness.
     * @param  {String} (mbean) The mbean name to sort
     * @return {String} The sorted mbean string
    */


    JolokiaSrv.prototype.sort_mbean = function(mbean) {
      var minfo, suffix;
      minfo = mbean.split(':');
      suffix = minfo.pop();
      minfo.push(suffix.split(',').sort().join(','));
      return minfo.join(':');
    };

    /**
     * Merges the parent template with the current template.
     * @param  {String} (template) The template to merge
     * @return {Object} The merged template
    */


    JolokiaSrv.prototype.merge_parent_templates = function(template) {
      var inherits, mappings;
      mappings = this.templates[template].mappings;
      inherits = this.templates[template].inherits;
      if (inherits === null || inherits === void 0) {
        return mappings;
      } else {
        return this.merge_mappings(this.merge_parent_templates(inherits), mappings);
      }
    };

    /**
     * Extends a base mapping with the given extension
     * @param  {Array} (base) The base template mapping
     * @param  {Array} (extension) The extension mapping
     * @return {Array} The merged extension mapping
    */


    JolokiaSrv.prototype.merge_mappings = function(base, extension) {
      var base_mappings, base_only, bmerge, emerge, extension_mappings, extension_only, m, merge_objs, merged_map, merges, _i, _len;
      if (base === void 0) {
        return extension;
      }
      if (extension === void 0) {
        return base;
      }
      merged_map = [];
      base_mappings = base.map(function(X) {
        return X.mbean;
      });
      extension_mappings = extension.map(function(X) {
        return X.mbean;
      });
      extension_only = extension_mappings.filter(function(X) {
        return __indexOf.call(base_mappings, X) < 0;
      });
      base_only = base_mappings.filter(function(X) {
        return __indexOf.call(extension_mappings, X) < 0;
      });
      merge_objs = new Object();
      base_mappings.concat(extension_mappings).forEach(function(X) {
        if (merge_objs.hasOwnProperty(X)) {
          return merge_objs[X] += 1;
        } else {
          return merge_objs[X] = 1;
        }
      });
      merged_map = merged_map.concat(base.filter(function(X) {
        var _ref;
        return _ref = X.mbean, __indexOf.call(base_only, _ref) >= 0;
      }));
      merged_map = merged_map.concat(extension.filter(function(X) {
        var _ref;
        return _ref = X.mbean, __indexOf.call(extension_only, _ref) >= 0;
      }));
      merges = Object.keys(merge_objs).filter(function(X) {
        return merge_objs[X] > 1;
      });
      for (_i = 0, _len = merges.length; _i < _len; _i++) {
        m = merges[_i];
        bmerge = (base.filter(function(X) {
          return X.mbean === m;
        })).pop();
        emerge = (extension.filter(function(X) {
          return X.mbean === m;
        })).pop();
        bmerge.attributes = this.merge_attributes_or_composites(bmerge.attributes, emerge.attributes);
        merged_map.push(bmerge);
      }
      return merged_map;
    };

    /**
     * Extends a base attribute/composite with given extensions.
     * @param  {Array} (base) The base composite array
     * @param  {Array} (extension) The extended composite array
     * @return {Array} The merged composite array
    */


    JolokiaSrv.prototype.merge_attributes_or_composites = function(base, extension) {
      var base_composites, base_only, bmerge, emerge, extension_composites, extension_only, k, m, merge_objs, merged_map, merges, _i, _j, _len, _len1, _ref;
      if (extension === null || extension === void 0) {
        return base;
      }
      if (base === null || base === void 0) {
        return extension;
      }
      merged_map = [];
      base_composites = base.map(function(X) {
        return X.name;
      });
      extension_composites = extension.map(function(X) {
        return X.name;
      });
      extension_only = extension_composites.filter(function(X) {
        return __indexOf.call(base_composites, X) < 0;
      });
      base_only = base_composites.filter(function(X) {
        return __indexOf.call(extension_composites, X) < 0;
      });
      merge_objs = new Object();
      base_composites.concat(extension_composites).forEach(function(X) {
        if (merge_objs.hasOwnProperty(X)) {
          return merge_objs[X] += 1;
        } else {
          return merge_objs[X] = 1;
        }
      });
      merged_map = merged_map.concat(base.filter(function(X) {
        var _ref;
        return _ref = X.name, __indexOf.call(base_only, _ref) >= 0;
      }));
      merged_map = merged_map.concat(extension.filter(function(X) {
        var _ref;
        return _ref = X.name, __indexOf.call(extension_only, _ref) >= 0;
      }));
      merges = Object.keys(merge_objs).filter(function(X) {
        return merge_objs[X] > 1;
      });
      for (_i = 0, _len = merges.length; _i < _len; _i++) {
        m = merges[_i];
        bmerge = (base.filter(function(X) {
          return X.name === m;
        })).pop();
        emerge = (extension.filter(function(X) {
          return X.name === m;
        })).pop();
        if (emerge.hasOwnProperty('graph')) {
          _ref = Object.keys(emerge.graph);
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            k = _ref[_j];
            bmerge.graph[k] = emerge.graph[k];
          }
        }
        if (emerge.hasOwnProperty('composites')) {
          if (bmerge.hasOwnProperty('composites')) {
            bmerge.composites = this.merge_attributes_or_composites(bmerge.composites, emerge.composites);
          } else {
            bmerge.composites = emerge.composites;
          }
        }
        merged_map.push(bmerge);
      }
      return merged_map;
    };

    /**
     * Generates the information for a given template including parents.
     * @param  {String} (template) The template to generate information for
     * @return {Object} The merged information for a given template
    */


    JolokiaSrv.prototype.generate_template_info = function(template) {
      if (this.templates[template] === void 0) {
        return this.templates[template];
      }
      if (this.templates[template].inherits === null || this.templates[template].inherits === void 0) {
        this.templates[template].inherits = null;
      }
      if (this.templates[template].inherits !== void 0) {
        return {
          mappings: this.merge_parent_templates(template)
        };
      } else {
        delete this.templates[template].inherits;
        return this.templates[template];
      }
    };

    /**
     * Generates a query information for the JMX update.
     * @param  {Object} (mappings) The detailed information for a client
     * @return {Array}  The list of info objects
    */


    JolokiaSrv.prototype.generate_query_info = function(client) {
      var attr, c, g, m, query_info, _i, _j, _len, _len1, _ref, _ref1;
      query_info = [];
      if (client.mappings !== null) {
        _ref = client.mappings;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          m = _ref[_i];
          _ref1 = m.attributes;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            attr = _ref1[_j];
            if (attr.hasOwnProperty('graph')) {
              g = attr.graph;
            } else {
              g = {};
            }
            if (attr.hasOwnProperty('composites')) {
              c = attr.composites;
            } else {
              c = [];
            }
            query_info.push({
              mbean: this.sort_mbean(m.mbean),
              attribute: attr.name,
              graph: g,
              composites: c
            });
          }
        }
        return query_info;
      }
    };

    /**
     * Generates a query array for the jolokia client.
     * @param  {Object} (query_info) The query info for a client
     * @return {Array}  The list of items to query
    */


    JolokiaSrv.prototype.generate_client_query = function(query_info) {
      var q, query, _i, _len;
      query = [];
      for (_i = 0, _len = query_info.length; _i < _len; _i++) {
        q = query_info[_i];
        query.push({
          mbean: this.sort_mbean(q.mbean),
          attribute: q.attribute
        });
      }
      return query;
    };

    /**
     * Takes the query_info and response objects and gets the proper result set.
     * @param {String} (name) The name of the client to query
     * @param {Object} (mappings) The metrics mappings for a client
     * @param {Object} (response) The query response from jolokia
     * @param {Function} (fn) The callback function
    */


    JolokiaSrv.prototype.lookup_attribute_or_composites = function(name, mappings, response, fn) {
      var _this = this;
      return this.convert_mappings_to_hash(mappings, function(h_err, hattribs) {
        var handle_response_obj;
        handle_response_obj = function(item, cb) {
          var attribute, k, keys, mbean, recursive_get_val, retrieve_composite_value, value, _i, _len;
          mbean = _this.sort_mbean(item.request.mbean);
          attribute = item.request.attribute;
          value = item.value;
          retrieve_composite_value = function(input) {
            if (typeof input === 'string') {
              input = input.split('|');
            }
            return recursive_get_val(value, input);
          };
          recursive_get_val = function(walk, list) {
            var next;
            if (list.length > 1) {
              next = list.shift();
              return recursive_get_val(walk[next], list);
            } else {
              return walk[list];
            }
          };
          try {
            if (hattribs[mbean][attribute].hasOwnProperty('graph') && Object.keys(hattribs[mbean][attribute].graph).length > 0) {
              hattribs[mbean][attribute].value = value;
            }
          } catch (error) {
            _this.logger.error("Error parsing attribute: " + error + "\nmbean: " + mbean + "\nattribute: " + attribute + "\n\njolokia_hash: " + (util.inspect(hattribs, true, 10)));
          }
          keys = (function() {
            var _i, _len, _ref, _results;
            _ref = Object.keys(hattribs[mbean][attribute]);
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              k = _ref[_i];
              if (k !== 'graph' && k !== 'value') {
                _results.push(k);
              }
            }
            return _results;
          })();
          for (_i = 0, _len = keys.length; _i < _len; _i++) {
            k = keys[_i];
            try {
              hattribs[mbean][attribute][k].value = retrieve_composite_value(k);
            } catch (error) {
              _this.logger.error("Error parsing composite attribute: " + error + "\nmbean: " + mbean + "\nattribute: " + attribute + "\ncomposite: " + k + "\n\njolokia_hash: " + (util.inspect(hattribs, true, 10)));
            }
          }
          return cb(null);
        };
        return async.each(response, handle_response_obj, function(err) {
          _this.jclients[name].cache = hattribs;
          return fn(null, hattribs);
        });
      });
    };

    /**
     * Queries jolokia mbeans for a given client and updates their values.
     * @param {String} (name) The name of the client to query
     * @param {Function} (fn) The callback function
    */


    JolokiaSrv.prototype.query_jolokia = function(name, fn) {
      var cinfo, client, query, query_info,
        _this = this;
      cinfo = this.info_client(name);
      query_info = this.generate_query_info(cinfo);
      query = this.generate_client_query(query_info);
      if (query === []) {
        return null;
      }
      client = this.jclients[name].client;
      return client.read(query, function(response) {
        return _this.lookup_attribute_or_composites(name, cinfo.mappings, response, fn);
      });
    };

    /**
     * Attempt to query each of the nodes, ignoring failures.
    */


    JolokiaSrv.prototype.query_all_jolokia_nodes = function(cb) {
      var attempt_to_query, client_list,
        _this = this;
      attempt_to_query = function(client, fn) {
        try {
          return _this.query_jolokia(client, function(err, attribs) {
            return fn(null);
          });
        } catch (error) {
          return fn(error);
        }
      };
      client_list = Object.keys(this.jclients);
      if (client_list.length > 0) {
        return async.each(client_list, attempt_to_query, function(err) {
          if (cb) {
            return cb(null);
          }
        });
      } else {
        if (cb) {
          return cb(null);
        }
      }
    };

    /**
     * Returns detailed information for all clients.
     * @return {Object} The hash representing the all client info
    */


    JolokiaSrv.prototype.info_all_clients = function() {
      var clients, key, _i, _len, _ref;
      clients = new Object();
      _ref = Object.keys(this.jclients);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        clients[key] = this.info_client(key);
      }
      return clients;
    };

    /**
     * Starts up the gmond metric spooler.
    */


    JolokiaSrv.prototype.start_gmond = function() {
      var _this = this;
      if (!this.interval) {
        return;
      }
      if (this.gmond_interval_id) {
        this.stop_gmond();
      }
      return this.gmond_interval_id = setInterval(function() {
        _this.query_all_jolokia_nodes();
        return _this.submit_metrics();
      }, this.interval * 1000);
    };

    /**
     * Stops the gmond metric spooler.
    */


    JolokiaSrv.prototype.stop_gmond = function() {
      if (this.gmond_interval_id) {
        clearInterval(this.gmond_interval_id);
        return this.gmond_interval_id = null;
      }
    };

    /**
     * Submits gmetric data to the gmond target.
     * ex:  { host:  'exhost.domain.com',
     *        name:  'mygraphname',
     *        units: 'percentage',
     *        type:  'int32',
     *        slope: 'both',
     *        tmax:   60,
     *        dmax:   120,
     *        group:  'mygraph_group',
     *        cluster: 'example_cluster' }
    */


    JolokiaSrv.prototype.submit_metrics = function() {
      var clientlist, compile_and_submit_metric, walk_graphs,
        _this = this;
      clientlist = Object.keys(this.jclients);
      if (!(clientlist.length > 0)) {
        return;
      }
      walk_graphs = function(client, cache, cluster) {
        var ainfo, attrib, c, comp, mbean, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
        if (Object.keys(_this.jclients[client]) === 0) {
          return;
        }
        _ref = Object.keys(cache);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          mbean = _ref[_i];
          mbean = _this.sort_mbean(mbean);
          _ref1 = Object.keys(cache[mbean]);
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            attrib = _ref1[_j];
            ainfo = cache[mbean][attrib];
            if (ainfo === void 0) {
              return;
            }
            if (ainfo.hasOwnProperty('graph') && ainfo.hasOwnProperty('value')) {
              compile_and_submit_metric(client, ainfo.graph, ainfo.value, cluster);
            }
            _ref2 = Object.keys(cache[mbean][attrib]);
            for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
              comp = _ref2[_k];
              c = cache[mbean][attrib][comp];
              if (c === void 0) {
                return;
              }
              if (c.hasOwnProperty('graph') && c.hasOwnProperty('value')) {
                compile_and_submit_metric(client, c.graph, c.value, cluster);
              }
            }
          }
        }
      };
      compile_and_submit_metric = function(client, graph, value, cluster) {
        var metric;
        metric = graph;
        metric.value = value;
        if (cluster === null || cluster === void 0) {
          metric.cluster = _this.config.get('cluster');
        } else {
          metric.cluster = cluster;
        }
        cluster = [_this.config.get('cluster_prefix'), metric.cluster].filter(function(x) {
          return x !== null && x !== void 0;
        });
        metric.cluster = cluster.join('_');
        metric.hostname = client;
        metric.spoof = true;
        metric.spoof_host = client;
        if (metric.value === void 0) {
          metric.value = 0;
        }
        if (metric.type === void 0) {
          metric.type = 'int32';
        }
        if (metric.slope === void 0) {
          metric.slope = 'both';
        }
        return _this.gmetric.send(_this.config.get('gmetric'), _this.config.get('gPort'), metric);
      };
      return async.each(clientlist, function(client, cb) {
        return walk_graphs(client, _this.jclients[client].cache, _this.jclients[client].cluster);
      }, function(err) {
        return _this.logger.error("Error submitting metrics: " + err);
      });
    };

    return JolokiaSrv;

  })();

  module.exports = JolokiaSrv;

}).call(this);
