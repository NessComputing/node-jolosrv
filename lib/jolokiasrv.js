// Generated by CoffeeScript 1.4.0
(function() {
  var Config, Gmetric, Jolokia, JolokiaSrv, async,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Jolokia = require('jolokia-client');

  async = require('async');

  Gmetric = require('gmetric');

  Config = require('./config');

  /**
   * Jolokia server client wrapper.
  */


  JolokiaSrv = (function() {

    function JolokiaSrv(interval) {
      this.interval = interval;
      this.submit_metrics = __bind(this.submit_metrics, this);
      this.stop_gmond = __bind(this.stop_gmond, this);
      this.start_gmond = __bind(this.start_gmond, this);
      this.info_all_clients = __bind(this.info_all_clients, this);
      this.query_jolokia = __bind(this.query_jolokia, this);
      this.lookup_attribute_or_composites = __bind(this.lookup_attribute_or_composites, this);
      this.generate_client_query = __bind(this.generate_client_query, this);
      this.generate_query_info = __bind(this.generate_query_info, this);
      this.info_client = __bind(this.info_client, this);
      this.remove_client = __bind(this.remove_client, this);
      this.list_clients = __bind(this.list_clients, this);
      this.remove_attributes = __bind(this.remove_attributes, this);
      this.convert_attribs_to_hash = __bind(this.convert_attribs_to_hash, this);
      this.add_client = __bind(this.add_client, this);
      this.interval || (this.interval = 15);
      this.jclients = new Object();
      this.gmond_interval_id = null;
      this.config = Config.get();
    }

    /**
     * Add a new jolokia lookup client into the hash.
     * @param  {String}  (name) The name of the client to add
     * @param  {String}  (url) The jolokia url for the client
     * @param  {Object}  (attributes) The attributes to lookup for the client
     * @return {Object}  The jolokia client that was added
    */


    JolokiaSrv.prototype.add_client = function(name, url, attributes) {
      return this.jclients[name] = {
        client: new Jolokia(url),
        attributes: attributes || new Object(),
        cache: new Object()
      };
    };

    /**
     * Cleanup attributes for a client before they are cached for fast lookups.
    */


    JolokiaSrv.prototype.convert_attribs_to_hash = function(attributes, fn) {
      var util,
        _this = this;
      util = require('util');
      return async.reduce(attributes, new Object(), function(mbean_memo, mbean_attr, mbean_cb) {
        var _name;
        mbean_memo[_name = mbean_attr.mbean] || (mbean_memo[_name] = new Object());
        return async.reduce(mbean_attr.attributes, new Object(), function(a_memo, a_attr, a_cb) {
          var _name1;
          a_memo[_name1 = a_attr.name] || (a_memo[_name1] = new Object());
          if (a_attr.hasOwnProperty('graph') && Object.keys(a_attr.graph).length > 0) {
            a_memo[a_attr.name].graph = a_attr.graph;
          }
          if (a_attr.hasOwnProperty('value')) {
            a_memo[a_attr.name].value = a_attr.value;
          }
          if (a_attr.hasOwnProperty('composites') && a_attr.composites.length > 0) {
            return async.forEach(a_attr.composites, function(cmp_attr, cmp_cb) {
              var _base, _name2;
              console.log(a_attr.name);
              (_base = a_memo[a_attr.name])[_name2 = cmp_attr.name] || (_base[_name2] = new Object());
              if (cmp_attr.hasOwnProperty('graph') && Object.keys(cmp_attr.graph).length > 0) {
                a_memo[a_attr.name][cmp_attr.name].graph = cmp_attr.graph;
              }
              if (cmp_attr.hasOwnProperty('value')) {
                a_memo[a_attr.name][cmp_attr.name].value = cmp_attr.value;
              }
              return cmp_cb(null);
            }, function(cmp_err) {
              return a_cb(null, a_memo);
            });
          } else {
            return a_cb(null, a_memo);
          }
        }, function(a_err, a_results) {
          return mbean_cb(a_err, mbean_memo);
        });
      }, function(err, results) {
        console.log('');
        console.log(util.inspect(results, true, 10));
        return fn(err, results);
      });
    };

    /**
     * Removes all jolokia attributes for the given client.
     * @param {String} (name) The name of the client to remove attributes of
    */


    JolokiaSrv.prototype.remove_attributes = function(name) {
      var key, _i, _len, _ref, _results;
      if (!this.jclients[name]) {
        return;
      }
      if (!(Object.keys(this.jclients[name]['attributes']).length > 0)) {
        return;
      }
      _ref = Object.keys(this.jclients[name]['attributes']);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        _results.push(delete this.jclients[name]['attributes'][key]);
      }
      return _results;
    };

    /**
     * List the current jolokia clients.
     * @return {Array} The list of current clients
    */


    JolokiaSrv.prototype.list_clients = function() {
      return Object.keys(this.jclients);
    };

    /**
     * Removes a jolokia client from the hash.
     * @param  {String} (name) The name of the client to remove
     * @return {String} The list of remaining clients
    */


    JolokiaSrv.prototype.remove_client = function(name) {
      delete this.jclients[name];
      return this.list_clients();
    };

    /**
     * Returns detailed information for the given client.
     * @param  {String} (name) The name of the client to lookup
     * @return {Object} The hash representing the client info
    */


    JolokiaSrv.prototype.info_client = function(name) {
      var client;
      client = this.jclients[name];
      if (client) {
        return client['attributes'];
      } else {
        return null;
      }
    };

    /**
     * Generates a query information for the JMX update.
     * @param  {Object} (attributes) The detailed information for a client
     * @return {Array}  The list of info objects
    */


    JolokiaSrv.prototype.generate_query_info = function(attributes) {
      var attr, c, g, m, query_info, _i, _j, _len, _len1, _ref;
      query_info = [];
      if (attributes !== null) {
        for (_i = 0, _len = attributes.length; _i < _len; _i++) {
          m = attributes[_i];
          _ref = m.attributes;
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            attr = _ref[_j];
            if (attr.hasOwnProperty('graph')) {
              g = attr.graph;
            } else {
              g = {};
            }
            if (attr.hasOwnProperty('composites')) {
              c = attr.composites;
            } else {
              c = [];
            }
            query_info.push({
              mbean: m.mbean,
              attribute: attr.name,
              graph: g,
              composites: c
            });
          }
        }
        return query_info;
      }
    };

    /**
     * Generates a query array for the jolokia client.
     * @param  {Object} (query_info) The query info for a client
     * @return {Array}  The list of items to query
    */


    JolokiaSrv.prototype.generate_client_query = function(query_info) {
      var q, query, _i, _len;
      query = [];
      for (_i = 0, _len = query_info.length; _i < _len; _i++) {
        q = query_info[_i];
        query.push({
          mbean: q.mbean,
          attribute: q.attribute
        });
      }
      return query;
    };

    /**
     * Takes the query_info and response objects and gets the proper result set.
     * @param {String} (name) The name of the client to query
     * @param {Object} (query_info) The list of info objects for a client
     * @param {Object} (response) The query response from jolokia
     * @param {Function} (fn) The callback function
    */


    JolokiaSrv.prototype.lookup_attribute_or_composites = function(name, query_info, response, fn) {
      var generate_obj, util,
        _this = this;
      util = require('util');
      console.log(util.inspect(response, true, 10));
      console.log(util.inspect(query_info, true, 10));
      generate_obj = function(item, fn) {
        return {
          mbean: '',
          attribute: '',
          value: '',
          graph: ''
        };
      };
      return async.map(response, generate_obj, function(err, results) {
        console.log(err);
        console.log(results);
        _this.jclients[name].cache = results;
        return fn(null, results);
      });
    };

    /**
     * Queries jolokia mbeans for a given client and updates their values.
     * @param {String} (name) The name of the client to query
     * @param {Function} (fn) The callback function
    */


    JolokiaSrv.prototype.query_jolokia = function(name, fn) {
      var attrs, client, query, query_info,
        _this = this;
      attrs = this.info_client(name);
      query_info = this.generate_query_info(attrs);
      query = this.generate_client_query(query_info);
      if (query === []) {
        return null;
      }
      client = this.jclients[name].client;
      return client.read(query, function(response) {
        return _this.lookup_attribute_or_composites(name, query_info, response, fn);
      });
    };

    /**
     * Returns detailed information for all clients.
     * @return {Object} The hash representing the all client info
    */


    JolokiaSrv.prototype.info_all_clients = function() {
      var clients, key, _i, _len, _ref;
      clients = new Object();
      _ref = Object.keys(this.jclients);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        clients[key] = this.info_client(key);
      }
      return clients;
    };

    /**
     * Starts up the gmond metric spooler.
    */


    JolokiaSrv.prototype.start_gmond = function(host, port, spoof) {
      var _this = this;
      if (!this.interval) {
        return;
      }
      if (this.gmond_interval_id) {
        stop_gmond();
      }
      return this.gmond_interval_id = setInterval(function() {
        return _this.submit_metrics();
      }, this.interval);
    };

    /**
     * Stops the gmond metric spooler.
    */


    JolokiaSrv.prototype.stop_gmond = function() {
      if (this.gmond_interval_id) {
        clearInterval(this.gmond_interval_id);
        return this.gmond_interval_id = null;
      }
    };

    /**
     * Submits gmetric data to the gmond target.
     * ex:  { host:  'exhost.domain.com',
     *        name:  'mygraphname',
     *        units: 'percentage', 
     *        type:  'int32',
     *        slope: 'both',
     *        tmax:   60,
     *        dmax:   120,
     *        group:  'mygraph_group' }
    */


    JolokiaSrv.prototype.submit_metrics = function() {
      var clients;
      return clients = this.info_all_clients();
    };

    return JolokiaSrv;

  })();

  module.exports = JolokiaSrv;

}).call(this);
